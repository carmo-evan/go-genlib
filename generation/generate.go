package generation

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/dave/jennifer/jen"
	"github.com/efritz/go-genlib/command"
	"github.com/efritz/go-genlib/paths"
	"github.com/efritz/go-genlib/types"
)

type (
	FilenameGenerator  func(name string) string
	InterfaceGenerator func(file *jen.File, iface *types.Interface, prefix string)
)

func Generate(
	appName string,
	ifaces []*types.Interface,
	opts *command.Options,
	filenameGenerator FilenameGenerator,
	interfaceGenerator InterfaceGenerator,
) error {
	importPath, err := inferImportPath(opts.OutputDir)
	if err != nil {
		return err
	}

	for _, iface := range ifaces {
		if iface.ImportPath == importPath {
			iface.ImportPath = ""
		}
	}

	if opts.OutputFilename == "" && opts.OutputDir != "" {
		return generateDirectory(
			appName,
			ifaces,
			opts,
			filenameGenerator,
			interfaceGenerator,
		)
	}

	return generateFile(appName, ifaces, opts, interfaceGenerator)
}

func inferImportPath(path string) (string, error) {
	gopath := paths.Gopath()
	if strings.HasPrefix(path, gopath) {
		// gopath + /src/
		return path[len(gopath)+5:], nil
	}

	return "", fmt.Errorf("destination is outside $GOPATH")
}

func generateFile(
	appName string,
	ifaces []*types.Interface,
	opts *command.Options,
	interfaceGenerator InterfaceGenerator,
) error {
	content, err := generateContent(
		appName,
		ifaces,
		opts.PkgName,
		opts.Prefix,
		interfaceGenerator,
	)

	if err != nil {
		return err
	}

	if opts.OutputFilename != "" {
		exists, err := paths.Exists(opts.OutputFilename)
		if err != nil {
			return err
		}

		if exists && !opts.Force {
			return fmt.Errorf("filename %s already exists", opts.OutputFilename)
		}

		return writeFile(opts.OutputFilename, content)
	}

	fmt.Printf("%s\n", content)
	return nil
}

func generateDirectory(
	appName string,
	ifaces []*types.Interface,
	opts *command.Options,
	filenameGenerator FilenameGenerator,
	interfaceGenerator InterfaceGenerator,
) error {
	dirname := filepath.Join(opts.OutputDir, opts.OutputFilename)

	if !opts.Force {
		allPaths := []string{}
		for _, iface := range ifaces {
			allPaths = append(allPaths, getFilename(
				dirname,
				iface.Name,
				opts.Prefix,
				filenameGenerator,
			))
		}

		conflict, err := paths.AnyExists(allPaths)
		if err != nil {
			return err
		}

		if conflict != "" {
			return fmt.Errorf("filename %s already exists", conflict)
		}
	}

	for _, iface := range ifaces {
		content, err := generateContent(
			appName,
			[]*types.Interface{iface},
			opts.PkgName,
			opts.Prefix,
			interfaceGenerator,
		)

		if err != nil {
			return err
		}

		filename := getFilename(
			dirname,
			iface.Name,
			opts.Prefix,
			filenameGenerator,
		)

		if err := writeFile(filename, content); err != nil {
			return err
		}
	}

	return nil
}

func getFilename(dirname, interfaceName, prefix string, filenameGenerator FilenameGenerator) string {
	filename := filenameGenerator(interfaceName)
	if prefix != "" {
		filename = fmt.Sprintf("%s_%s", prefix, filename)
	}

	return path.Join(dirname, strings.Replace(strings.ToLower(filename), "-", "_", -1))
}

func generateContent(
	appName string,
	ifaces []*types.Interface,
	pkgName string,
	prefix string,
	interfaceGenerator InterfaceGenerator,
) (string, error) {
	file := newFile(appName, pkgName)

	for _, iface := range ifaces {
		interfaceGenerator(file, iface, prefix)
	}

	buffer := &bytes.Buffer{}
	if err := file.Render(buffer); err != nil {
		return "", err
	}

	return buffer.String(), nil
}

func newFile(appName, pkgName string) *jen.File {
	file := jen.NewFile(pkgName)
	file.HeaderComment(fmt.Sprintf("Code generated by %s; DO NOT EDIT.", appName))
	file.HeaderComment("This file was generated by robots at")
	file.HeaderComment(time.Now().Format(time.RFC3339))
	file.HeaderComment("using the command")
	file.HeaderComment(fmt.Sprintf("$ %s", strings.Join(os.Args, " ")))

	return file
}

func writeFile(filename, content string) error {
	return ioutil.WriteFile(filename, []byte(content), 0644)
}
